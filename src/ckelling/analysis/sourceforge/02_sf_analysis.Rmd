---
title: "SourceForgeAnalysis"
author: "Claire Kelling"
date: "7/6/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
load(file = '~/git/oss/data/oss/working/sourceforge/cleaned_SF.RData')
cleaned_SF <- as.data.frame(cleaned_SF)
library(ggplot2)
library(plyr)
library(dplyr)
```

## Analysis of Sourceforge Data

First, I will assess the completeness of the 16/17 variables.
```{r completeness, echo=FALSE,include= TRUE}
# profile_dat <- c()
# for(i in 1:ncol(cleaned_SF)){
#   print(i)
#   if(i == 12){
#     x <- cleaned_SF[,i]
# 
#     # Make all blanks NAs
#     x[x == ""] <- NA
# 
#     name <- colnames(cleaned_SF)[i]
#     class <- class(x)
# 
#     # Proportion of missing values
#     miss <- round(sum(is.na(x))*100/nrow(cleaned_SF), digits = 2)
# 
#     # How many unique values to the variable?
#     auth <- c()
#     for(j in 1:length(x)){
#       print(j)
#       new_auth <- trimws(unlist(str_split(x[j], ",")))
#       auth <- c(auth, new_auth)
#     }
# 
#     vals <- length(unique(auth))
#     # summary <- summary(x)
#     #if(vals <= 10){
#     #  tab <- table(x)
#     #  print(tab)
#     #}
#   }else{
#     x <- cleaned_SF[,i]
# 
#     # Make all blanks NAs
#     x[x == ""] <- NA
# 
#     name <- colnames(cleaned_SF)[i]
#     class <- class(x)
# 
#     # Proportion of missing values
#     miss <- round(sum(is.na(x))*100/nrow(cleaned_SF), digits = 2)
# 
#     # How many unique values to the variable?
#     vals <- length(unique(x))
#     # summary <- summary(x)
#     #if(vals <= 10){
#     #  tab <- table(x)
#     #  print(tab)
#     #}
#   }
#   new_row <- c(name, class, miss, vals)
#   profile_dat <- rbind(profile_dat, new_row)
# }
# colnames(profile_dat) <- c("Column Name", "Class", "% Missing" , "Unique Values")
load( file = '~/git/oss/data/oss/working/sourceforge/profile_dat.RData')
colnames(profile_dat) <- c("Column Name", "Class", "% Missing" , "Unique Values")
rownames(profile_dat) <- c()
profile_dat <- as.data.frame(profile_dat)

print(profile_dat)
```

I would like to look at some histograms of the quantitative variables.
```{r histograms, echo =FALSE}
hist(as.numeric(cleaned_SF$Average.Rating))
hist(as.numeric(cleaned_SF$Number.of.Ratings))
hist(as.numeric(cleaned_SF$Number.of.Ratings[which(as.numeric(cleaned_SF$Number.of.Ratings) > 5)]))
hist(as.numeric(cleaned_SF$Weekly.Downloads))
hist(as.numeric(cleaned_SF$Weekly.Downloads[which(as.numeric(cleaned_SF$Weekly.Downloads) >5 & as.numeric(cleaned_SF$Weekly.Downloads) < 50000)]))
hist(as.numeric(cleaned_SF$Ease))
hist(as.numeric(cleaned_SF$features))
hist(as.numeric(cleaned_SF$design))
hist(as.numeric(cleaned_SF$support))
```

```{r last update, echo=FALSE, include=TRUE}
#plot last updated over time!
library(lubridate)

## Change the column's class to be compatible with lubridate
cleaned_SF$Last.Update <- as.POSIXct(as.character(cleaned_SF$Last.Update), format = "%Y-%m-%d")
data <- cleaned_SF

## Pull components of the date
# data$min <- factor(min(cleaned_SF$Received_Date_Time))
# data$hour <- factor(hour(cleaned_SF$Received_Date_Time))
data$date <- factor(day(cleaned_SF$Last.Update))
data$month <- factor(month(cleaned_SF$Last.Update))
data$year <- factor(year(cleaned_SF$Last.Update))

## Group it by date and hour
summary <- data %>%
  group_by(year, month) %>%
  summarise(freq = length(OSS.Title))

summary$date <- as.Date(paste0('01','/',as.character(summary$month), '/', as.character(summary$year)), "%d/%m/%Y")


## Plot frequency lines
ggplot(summary, aes(x=date, y=freq))+
  geom_line(aes(group = 1,colour = substr(date,6,7))) +
  #geom_point() +
  ggtitle("Last Update Over Time") +
  labs(x = "Date", y = "Total Update") +
  theme(plot.title = element_text(hjust = 0.5))


ggplot(summary, aes(month, freq)) +
   geom_line(aes(color = year, group = year)) +
   geom_point() +
   ggtitle("Last Update Over Time") +
   labs(x = "Date", y = "Total update") +
   theme(plot.title = element_text(hjust = 0.5))
```

Now, I would like to do the same for the date registered.
```{r date reg, echo=FALSE, include=TRUE}
#plot date registered over time!

## Change the column's class to be compatible with lubridate
cleaned_SF$Date.registered <- as.POSIXct(as.character(cleaned_SF$Date.registered), format = "%Y-%m-%d")
data <- cleaned_SF

## Pull components of the date
# data$min <- factor(min(cleaned_SF$Received_Date_Time))
# data$hour <- factor(hour(cleaned_SF$Received_Date_Time))
data$date <- factor(day(cleaned_SF$Date.registered))
data$month <- factor(month(cleaned_SF$Date.registered))
data$year <- factor(year(cleaned_SF$Date.registered))

## Group it by date and hour
summary <- data %>%
  group_by(year, month) %>%
  summarise(freq = length(OSS.Title))

summary$date <- as.Date(paste0('01','/',as.character(summary$month), '/', as.character(summary$year)), "%d/%m/%Y")


## Plot frequency lines
ggplot(summary, aes(x=date, y=freq))+
  geom_line(aes(group = 1,colour = substr(date,6,7))) +
  #geom_point() +
  ggtitle("Date Registered Over Time") +
  labs(x = "Date", y = "Total Update") +
  theme(plot.title = element_text(hjust = 0.5))


ggplot(summary, aes(month, freq)) +
   geom_line(aes(color = year, group = year)) +
   geom_point() +
   ggtitle("Date Registered Over Time") +
   labs(x = "Date", y = "Total update") +
   theme(plot.title = element_text(hjust = 0.5))
```



Now, I would like to assess the universe by looking at categories.
```{r plot of categories}
agg_dat <- plyr::count(cleaned_SF, c('Category.1', 'Category.2', 'Category.3'))
agg_dat1 <- plyr::count(cleaned_SF, c('Category.1', 'Category.2'))

ggplot(agg_dat1)+ geom_bar(aes(x=Category.1, y=freq,fill = Category.2), stat= "identity")+ theme(legend.position="none",axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle("Categories and Subcategories")

```

```{r network images, message = FALSE, include = FALSE}
library(dplyr)
library(DiagrammeR)
library(plyr)

source("~/git/oss/src/ckelling/analysis/sourceforge/dan_functions.R")
load(file = '~/git/oss/data/oss/working/sourceforge/cleaned_SF.RData')
cleaned_SF <- as.data.frame(cleaned_SF)
agg_dat <- plyr::count(cleaned_SF, c('Category.1', 'Category.2', 'Category.3'))


#Full network
network_graph(agg_dat)

#Audio and Video Graph
av_counts = agg_dat[which(agg_dat$Category.1 == "Audio & Video"),]
network_graph(av_counts)#, title = "Category: Audio and Video")

#Business and Enterprise Graph
be_counts = agg_dat[which(agg_dat$Category.1 == "Business & Enterprise"),]
network_graph(be_counts)

#Communications Graph
comm_counts = agg_dat[which(agg_dat$Category.1 == "Communications"),]
network_graph(comm_counts)

#Development Graph
dev_counts = agg_dat[which(agg_dat$Category.1 == "Development"),]
network_graph(dev_counts)

#Games and Graphics Graph
#need to edit graphics a bit
for(i in 1:nrow(agg_dat)){
  if(agg_dat$Category.1[i]=="Graphics" & is.na(agg_dat$Category.1[i]) == FALSE){
    agg_dat$Category.2[i] <- agg_dat$Category.3[i]
    agg_dat$Category.3[i] <- NA
  }
}
gg_counts = agg_dat[which(agg_dat$Category.1 == "Graphics" | agg_dat$Category.1 == "Games"),]
network_graph(gg_counts)

#Home and Education and Other Graph
he_counts = agg_dat[which(agg_dat$Category.1 == "Home & Education" | agg_dat$Category.1 == "Multimedia" | agg_dat$Category.1 == "Other/Nonlisted Topic"),]
network_graph(he_counts)

#Science and Engineering
se_counts = agg_dat[which(agg_dat$Category.1 == "Science & Engineering"),]
network_graph(se_counts)

# Security and Utilities
su_counts = agg_dat[which(agg_dat$Category.1 == "Security & Utilities"),]
network_graph(su_counts)

#System Administration
sa_counts = agg_dat[which(agg_dat$Category.1 == "System Administration"),]
network_graph(sa_counts)

#NA
#na_counts = agg_dat[which(is.na(agg_dat$Category.1)),]
#network_graph(na_counts
na_val = print(agg_dat[which(is.na(agg_dat$Category.1)),][,4])
paste("Number of NA values: ", na_val, ", which is ", round(na_val/sum(agg_dat$freq),3)*100, "%.", sep="")

# #https://github.com/rich-iannone/DiagrammeR/issues/133
# 
# pdf_digraph <- function(filename, code){
#   capture.output({
#   g <- grViz(paste("digraph{", code, "}"))
#   DiagrammeRsvg::export_svg(g) %>% charToRaw %>% rsvg::rsvg_pdf(filename)
#   },  file='NUL')
#   knitr::include_graphics(filename)
# }
# 
# pdf_digraph("test",network_graph(sa_counts))

```


This provides an example of one of the networks. I have created networks for all of the other categories, but as of now, they are too large to share in the Rmarkdown document.
```{r net example, echo=FALSE, include= TRUE}
se_counts = agg_dat[which(agg_dat$Category.1 == "Science & Engineering"),]
network_graph(se_counts)
```

